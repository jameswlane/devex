name: Multi-Component Release
on:
  push:
    branches: [main]
    paths:
      - 'apps/**'
      - 'packages/**'
  workflow_dispatch:
    inputs:
      component:
        description: 'Component to release (cli, sdk, plugins, or all)'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - cli
          - sdk
          - plugins
          - all
      version_bump:
        description: 'Version bump type'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major

concurrency: ${{ github.workflow }}-${{ github.ref }}

permissions:
  contents: write
  pull-requests: write
  packages: write

jobs:
  detect-changes:
    name: Detect Component Changes
    runs-on: ubuntu-latest
    outputs:
      cli_changed: ${{ steps.changes.outputs.cli }}
      sdk_changed: ${{ steps.changes.outputs.sdk }}
      plugins_changed: ${{ steps.changes.outputs.plugins }}
      changed_plugins: ${{ steps.plugins.outputs.changed_plugins }}
      cli_version_bump: ${{ steps.conventional.outputs.cli_version_bump }}
      sdk_version_bump: ${{ steps.conventional.outputs.sdk_version_bump }}
      plugins_version_bump: ${{ steps.conventional.outputs.plugins_version_bump }}
      should_release: ${{ steps.should-release.outputs.should_release }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: jdx/mise-action@v3
        with:
          install: true
          cache: true
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect file changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            cli:
              - 'apps/cli/**'
              - '!apps/cli/docs/**'
              - '!apps/cli/README.md'
            sdk:
              - 'packages/plugin-sdk/**'
              - '!packages/plugin-sdk/docs/**'
              - '!packages/plugin-sdk/README.md'
            plugins:
              - 'packages/**'
              - '!packages/plugin-sdk/**'
              - '!packages/*/docs/**'
              - '!packages/*/README.md'

      - name: Detect specific changed plugins
        if: steps.changes.outputs.plugins == 'true'
        id: plugins
        run: |
          # Get last tag or initial commit
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "Last tag: $LAST_TAG"

          # Get changed files since last tag
          CHANGED_FILES=$(git diff --name-only $LAST_TAG..HEAD)

          changed_plugins=()
          for file in $CHANGED_FILES; do
            if [[ $file == packages/* ]]; then
              plugin_dir=$(echo $file | cut -d'/' -f2)
              # Skip plugin-sdk and non-substantial changes
              if [ "$plugin_dir" != "plugin-sdk" ] && \
                 ! [[ $file =~ /docs/ ]] && \
                 ! [[ $file =~ README.md$ ]] && \
                 ([ -f "packages/$plugin_dir/main.go" ] || [ -f "packages/$plugin_dir/package.json" ]); then
                # Check if plugin_dir is not already in the array
                if ! printf '%s\n' "${changed_plugins[@]}" | grep -q "^${plugin_dir}$"; then
                  changed_plugins+=("$plugin_dir")
                fi
              fi
            fi
          done

          echo "changed_plugins=$(IFS=,; echo "${changed_plugins[*]}")" >> $GITHUB_OUTPUT
          echo "Changed plugins: ${changed_plugins[*]}"

      - name: Analyze conventional commits for version bumps
        id: conventional
        run: |
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || git rev-list --max-parents=0 HEAD)
          COMMITS=$(git log $LAST_TAG..HEAD --oneline --format="%s")

          echo "Analyzing commits since $LAST_TAG:"
          echo "$COMMITS"

          # Initialize version bumps
          cli_bump="none"
          sdk_bump="none"
          plugins_bump="none"

          # Analyze each commit
          while IFS= read -r commit; do
            echo "Analyzing: $commit"

            # Extract component and type from conventional commit
            # Use simpler approach to avoid complex regex patterns
            if [[ $commit =~ ^(feat|fix|perf|revert|refactor) ]]; then
              type="${BASH_REMATCH[1]}"

              # Check for breaking change marker
              if [[ $commit =~ !: ]]; then
                is_breaking=true
              else
                is_breaking=false
              fi

              # Extract component from scope if present
              if [[ $commit =~ \(([^)]+)\) ]]; then
                component="${BASH_REMATCH[1]}"
              else
                component=""
              fi

              echo "  Type: $type, Component: $component, Breaking: $is_breaking"

              # Determine version bump for this commit
              if [[ $is_breaking == true ]]; then
                bump="major"
              elif [[ $type == "feat" ]]; then
                bump="minor"
              elif [[ $type =~ ^(fix|perf|revert|refactor)$ ]]; then
                bump="patch"
              else
                bump="none"
              fi

              # Apply to components
              if [[ -z "$component" ]]; then
                # No component specified - affects all changed components
                if [[ "${{ steps.changes.outputs.cli }}" == "true" ]]; then
                  cli_bump=$(echo -e "$cli_bump\n$bump" | sort -V | tail -1)
                fi
                if [[ "${{ steps.changes.outputs.sdk }}" == "true" ]]; then
                  sdk_bump=$(echo -e "$sdk_bump\n$bump" | sort -V | tail -1)
                fi
                if [[ "${{ steps.changes.outputs.plugins }}" == "true" ]]; then
                  plugins_bump=$(echo -e "$plugins_bump\n$bump" | sort -V | tail -1)
                fi
              elif [[ $component == "cli" ]]; then
                cli_bump=$(echo -e "$cli_bump\n$bump" | sort -V | tail -1)
              elif [[ $component == "plugin-sdk" || $component == "sdk" ]]; then
                sdk_bump=$(echo -e "$sdk_bump\n$bump" | sort -V | tail -1)
              elif [[ $component =~ ^plugin ]]; then
                plugins_bump=$(echo -e "$plugins_bump\n$bump" | sort -V | tail -1)
              fi
            fi
          done <<< "$COMMITS"

          # Override with manual input if provided
          if [[ "${{ github.event.inputs.version_bump }}" != "auto" ]]; then
            case "${{ github.event.inputs.component }}" in
              cli) cli_bump="${{ github.event.inputs.version_bump }}" ;;
              sdk) sdk_bump="${{ github.event.inputs.version_bump }}" ;;
              plugins) plugins_bump="${{ github.event.inputs.version_bump }}" ;;
              all)
                cli_bump="${{ github.event.inputs.version_bump }}"
                sdk_bump="${{ github.event.inputs.version_bump }}"
                plugins_bump="${{ github.event.inputs.version_bump }}"
                ;;
            esac
          fi

          echo "cli_version_bump=$cli_bump" >> $GITHUB_OUTPUT
          echo "sdk_version_bump=$sdk_bump" >> $GITHUB_OUTPUT
          echo "plugins_version_bump=$plugins_bump" >> $GITHUB_OUTPUT

          echo "Final version bumps:"
          echo "  CLI: $cli_bump"
          echo "  SDK: $sdk_bump"
          echo "  Plugins: $plugins_bump"

      - name: Determine if release is needed
        id: should-release
        run: |
          should_release=false

          # Skip if commit message contains [skip ci]
          if [[ "${{ github.event.head_commit.message }}" == *"[skip ci]"* ]]; then
            echo "Skipping release due to [skip ci] in commit message"
            echo "should_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check manual trigger
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            should_release=true
          fi

          # Check if any component has changes and needs version bump
          if [[ "${{ steps.changes.outputs.cli }}" == "true" && "${{ steps.conventional.outputs.cli_version_bump }}" != "none" ]]; then
            should_release=true
          fi
          if [[ "${{ steps.changes.outputs.sdk }}" == "true" && "${{ steps.conventional.outputs.sdk_version_bump }}" != "none" ]]; then
            should_release=true
          fi
          if [[ "${{ steps.changes.outputs.plugins }}" == "true" && "${{ steps.conventional.outputs.plugins_version_bump }}" != "none" ]]; then
            should_release=true
          fi

          echo "should_release=$should_release" >> $GITHUB_OUTPUT
          echo "Should release: $should_release"

  release-cli:
    name: Release CLI
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should_release == 'true' && needs.detect-changes.outputs.cli_changed == 'true' && needs.detect-changes.outputs.cli_version_bump != 'none'
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Calculate new version
        id: version
        run: |
          # Get current CLI version
          CURRENT_VERSION=$(git tag -l "v*" | grep -v "packages\|plugins" | sort -V | tail -1 | sed 's/^v//')
          if [[ -z "$CURRENT_VERSION" ]]; then
            CURRENT_VERSION="0.0.0"
          fi

          echo "Current CLI version: v$CURRENT_VERSION"

          # Calculate new version based on bump type
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}

          case "${{ needs.detect-changes.outputs.cli_version_bump }}" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
            *) echo "Invalid version bump: ${{ needs.detect-changes.outputs.cli_version_bump }}"; exit 1 ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          NEW_TAG="v$NEW_VERSION"

          echo "New CLI version: $NEW_TAG"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: Create CLI release
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          VERSION="${{ steps.version.outputs.version }}"

          # Generate changelog since last CLI tag
          LAST_CLI_TAG=$(git tag -l "v*" | grep -v "packages\|plugins" | sort -V | tail -1)
          if [[ -n "$LAST_CLI_TAG" ]]; then
            CHANGELOG=$(git log $LAST_CLI_TAG..HEAD --oneline --grep="cli\|CLI\|^feat\|^fix" --format="- %s" || echo "- Initial release")
          else
            CHANGELOG="- Initial CLI release"
          fi

          # Create the tag
          git tag "$TAG" -m "CLI Release $VERSION"
          git push origin "$TAG"

          # Create GitHub release
          gh release create "$TAG" \
            --title "CLI Release $VERSION" \
            --notes "## DevEx CLI $VERSION

          ### Changes
          $CHANGELOG

          ### Installation

          #### Linux/macOS
          \`\`\`bash
          curl -fsSL https://devex.sh/install | bash
          \`\`\`

          #### Windows (PowerShell)
          \`\`\`powershell
          iwr -useb https://devex.sh/install.ps1 | iex
          \`\`\`

          #### Manual Download
          Download the appropriate binary for your platform from the assets below.

          ---
          **Full Changelog**: https://github.com/jameswlane/devex/compare/$LAST_CLI_TAG...$TAG" \
            --target main

          echo "✅ Created CLI release: $TAG"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  release-sdk:
    name: Release Plugin SDK
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should_release == 'true' && needs.detect-changes.outputs.sdk_changed == 'true' && needs.detect-changes.outputs.sdk_version_bump != 'none'
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Calculate new version
        id: version
        run: |
          # Get current SDK version
          CURRENT_VERSION=$(git tag -l "packages/plugin-sdk/v*" | sort -V | tail -1 | sed 's/^packages\/plugin-sdk\/v//')
          if [[ -z "$CURRENT_VERSION" ]]; then
            CURRENT_VERSION="0.0.0"
          fi

          echo "Current SDK version: packages/plugin-sdk/v$CURRENT_VERSION"

          # Calculate new version
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}

          case "${{ needs.detect-changes.outputs.sdk_version_bump }}" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
            *) echo "Invalid version bump: ${{ needs.detect-changes.outputs.sdk_version_bump }}"; exit 1 ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          NEW_TAG="packages/plugin-sdk/v$NEW_VERSION"

          echo "New SDK version: $NEW_TAG"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: Create SDK release
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          VERSION="${{ steps.version.outputs.version }}"

          # Generate changelog since last SDK tag
          LAST_SDK_TAG=$(git tag -l "packages/plugin-sdk/v*" | sort -V | tail -1)
          if [[ -n "$LAST_SDK_TAG" ]]; then
            CHANGELOG=$(git log $LAST_SDK_TAG..HEAD --oneline --grep="sdk\|SDK\|plugin-sdk" --format="- %s" || echo "- Initial release")
          else
            CHANGELOG="- Initial Plugin SDK release"
          fi

          # Create the tag
          git tag "$TAG" -m "Plugin SDK Release $VERSION"
          git push origin "$TAG"

          # Create GitHub release
          gh release create "$TAG" \
            --title "Plugin SDK Release $VERSION" \
            --notes "## DevEx Plugin SDK $VERSION

          ### Changes
          $CHANGELOG

          ### Installation

          \`\`\`go
          go get github.com/jameswlane/devex/packages/plugin-sdk@$TAG
          \`\`\`

          ### Usage

          Use this SDK to build DevEx plugins:

          \`\`\`go
          import \"github.com/jameswlane/devex/packages/plugin-sdk\"
          \`\`\`

          ---
          **Full Changelog**: https://github.com/jameswlane/devex/compare/$LAST_SDK_TAG...$TAG" \
            --target main

          echo "✅ Created SDK release: $TAG"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  release-plugins:
    name: Release Plugins
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should_release == 'true' && needs.detect-changes.outputs.plugins_changed == 'true' && needs.detect-changes.outputs.plugins_version_bump != 'none'
    strategy:
      matrix:
        plugin: ${{ fromJson(format('[{0}]', needs.detect-changes.outputs.changed_plugins)) }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up git user
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Calculate new version for ${{ matrix.plugin }}
        id: version
        run: |
          PLUGIN="${{ matrix.plugin }}"

          # Get current plugin version
          CURRENT_VERSION=$(git tag -l "plugins/$PLUGIN/v*" | sort -V | tail -1 | sed "s/^plugins\/$PLUGIN\/v//")
          if [[ -z "$CURRENT_VERSION" ]]; then
            CURRENT_VERSION="0.0.0"
          fi

          echo "Current $PLUGIN version: plugins/$PLUGIN/v$CURRENT_VERSION"

          # Calculate new version
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}

          case "${{ needs.detect-changes.outputs.plugins_version_bump }}" in
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
            minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
            patch) PATCH=$((PATCH + 1)) ;;
            *) echo "Invalid version bump: ${{ needs.detect-changes.outputs.plugins_version_bump }}"; exit 1 ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          NEW_TAG="plugins/$PLUGIN/v$NEW_VERSION"

          echo "New $PLUGIN version: $NEW_TAG"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT

      - name: Create plugin release for ${{ matrix.plugin }}
        run: |
          PLUGIN="${{ matrix.plugin }}"
          TAG="${{ steps.version.outputs.tag }}"
          VERSION="${{ steps.version.outputs.version }}"

          # Generate changelog since last plugin tag
          LAST_PLUGIN_TAG=$(git tag -l "plugins/$PLUGIN/v*" | sort -V | tail -1)
          if [[ -n "$LAST_PLUGIN_TAG" ]]; then
            CHANGELOG=$(git log $LAST_PLUGIN_TAG..HEAD --oneline --grep="$PLUGIN" --format="- %s" || echo "- Initial release")
          else
            CHANGELOG="- Initial $PLUGIN plugin release"
          fi

          # Create the tag
          git tag "$TAG" -m "Plugin $PLUGIN Release $VERSION"
          git push origin "$TAG"

          # Create GitHub release
          gh release create "$TAG" \
            --title "Plugin $PLUGIN Release $VERSION" \
            --notes "## DevEx Plugin: $PLUGIN $VERSION

          ### Changes
          $CHANGELOG

          ### Installation

          \`\`\`bash
          # Using DevEx CLI
          devex plugin install $PLUGIN

          # Manual download from assets below
          \`\`\`

          ---
          **Full Changelog**: https://github.com/jameswlane/devex/compare/$LAST_PLUGIN_TAG...$TAG" \
            --target main

          echo "✅ Created plugin release: $TAG"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-assets:
    name: Build and Attach Assets
    runs-on: ubuntu-latest
    needs: [detect-changes, release-cli, release-sdk, release-plugins]
    if: always() && needs.detect-changes.outputs.should_release == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: jdx/mise-action@v3
        with:
          install: true
          cache: true
          github_token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install GoReleaser Pro
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser-pro
          version: '~> v2'
          install-only: true
        env:
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}

      - name: Build and attach assets to releases
        run: |
          echo "Building assets for all new releases..."

          # Get all tags created in this workflow run
          CURRENT_SHA="${{ github.sha }}"

          # Find tags pointing to current commit
          CURRENT_TAGS=$(git tag --points-at HEAD)

          if [[ -z "$CURRENT_TAGS" ]]; then
            echo "No tags found at current commit, checking recent tags..."
            # Fallback: get tags from last few commits
            CURRENT_TAGS=$(git tag --merged HEAD | tail -5)
          fi

          echo "Processing tags: $CURRENT_TAGS"

          for tag in $CURRENT_TAGS; do
            echo "Processing tag: $tag"

            # Set environment variables for GoReleaser
            export GITHUB_TAG="$tag"

            if [[ $tag =~ ^v[0-9] ]]; then
              echo "Building CLI assets for $tag"
              export RELEASE_CLI="true"
              export RELEASE_SDK="false"
              export RELEASE_PLUGINS="false"
            elif [[ $tag =~ ^packages/plugin-sdk/ ]]; then
              echo "SDK release $tag - no assets to build"
              continue
            elif [[ $tag =~ ^plugins/ ]]; then
              echo "Building plugin assets for $tag"
              export RELEASE_CLI="false"
              export RELEASE_SDK="false"
              export RELEASE_PLUGINS="true"
              export CHANGED_PLUGINS="$(echo $tag | cut -d'/' -f2)"
            else
              echo "Unknown tag format: $tag"
              continue
            fi

            # Check if release exists
            if gh release view "$tag" >/dev/null 2>&1; then
              echo "Release exists for $tag, building assets..."

              # Create a clean build for this specific tag
              git checkout "$tag"

              # Run GoReleaser for this specific tag
              goreleaser release --clean --timeout=10m || {
                echo "GoReleaser failed for $tag, but continuing..."
                continue
              }

              echo "✅ Assets built and attached for $tag"
            else
              echo "No release found for $tag, skipping..."
            fi

            # Return to main branch
            git checkout main
          done

          echo "Asset building completed"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}

  notify:
    name: Notify Completion
    runs-on: ubuntu-latest
    needs: [detect-changes, release-cli, release-sdk, release-plugins, build-assets]
    if: always()
    steps:
      - name: Notify results
        run: |
          echo "🚀 Multi-Component Release Workflow Completed"
          echo ""
          echo "📊 Release Summary:"
          echo "Should release: ${{ needs.detect-changes.outputs.should_release }}"
          echo "CLI changed: ${{ needs.detect-changes.outputs.cli_changed }}"
          echo "SDK changed: ${{ needs.detect-changes.outputs.sdk_changed }}"
          echo "Plugins changed: ${{ needs.detect-changes.outputs.plugins_changed }}"
          echo "Changed plugins: ${{ needs.detect-changes.outputs.changed_plugins }}"
          echo ""
          echo "📈 Version Bumps:"
          echo "CLI: ${{ needs.detect-changes.outputs.cli_version_bump }}"
          echo "SDK: ${{ needs.detect-changes.outputs.sdk_version_bump }}"
          echo "Plugins: ${{ needs.detect-changes.outputs.plugins_version_bump }}"
          echo ""
          echo "🏷️ Releases Created:"
          if [[ "${{ needs.release-cli.outputs.tag }}" != "" ]]; then
            echo "✅ CLI: ${{ needs.release-cli.outputs.tag }}"
          fi
          if [[ "${{ needs.release-sdk.outputs.tag }}" != "" ]]; then
            echo "✅ SDK: ${{ needs.release-sdk.outputs.tag }}"
          fi
          echo ""
          echo "🔧 Job Results:"
          echo "Detect Changes: ${{ needs.detect-changes.result }}"
          echo "Release CLI: ${{ needs.release-cli.result }}"
          echo "Release SDK: ${{ needs.release-sdk.result }}"
          echo "Release Plugins: ${{ needs.release-plugins.result }}"
          echo "Build Assets: ${{ needs.build-assets.result }}"