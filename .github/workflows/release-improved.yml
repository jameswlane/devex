name: Release (Improved)
on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force release even without conventional commits'
        required: false
        default: false
        type: boolean
concurrency: ${{ github.workflow }}-${{ github.ref }}
permissions:
  contents: write
  pull-requests: write
  packages: write
jobs:
  # Job 1: Detect what packages need releasing
  detect-changes:
    name: Detect Package Changes
    runs-on: ubuntu-latest
    outputs:
      has_release: ${{ steps.changes.outputs.has_release }}
      packages: ${{ steps.changes.outputs.packages }}
      bump_type: ${{ steps.changes.outputs.bump_type }}
      release_data: ${{ steps.changes.outputs.release_data }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
      - name: Detect changes and calculate versions
        id: changes
        run: |
          # Set up git user for any git operations
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Get the last tag or use initial commit
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "Last tag: $LAST_TAG"

          # Check for conventional commits since last tag
          COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"%s" --no-merges | grep -E "^(feat|fix|perf|refactor)(\([^)]+\))?: " || echo "")

          # Allow forced releases
          if [[ "${{ github.event.inputs.force_release }}" == "true" ]]; then
            echo "Force release requested"
            COMMITS="fix: forced release"
          fi

          if [ -z "$COMMITS" ]; then
            echo "No conventional commits found since last release"
            echo "has_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Found conventional commits:"
          echo "$COMMITS"

          # Determine version bump type
          BUMP_TYPE="patch"
          if echo "$COMMITS" | grep -q "BREAKING CHANGE\|!:"; then
            BUMP_TYPE="major"
          elif echo "$COMMITS" | grep -q "^feat"; then
            BUMP_TYPE="minor"
          fi

          echo "Determined bump type: $BUMP_TYPE"

          # Get changed files since last tag
          CHANGED_FILES=$(git diff --name-only $LAST_TAG..HEAD || git diff --name-only --cached)
          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Filter out non-release-triggering changes
          RELEVANT_CHANGED_FILES=$(echo "$CHANGED_FILES" | grep -v -E "^\.github/|^apps/registry/|^apps/web/|^apps/docs/|^scripts/|^\.|README\.md$|\.md$|package\.json$|/dist/" || echo "")

          echo "Relevant changed files:"
          echo "$RELEVANT_CHANGED_FILES"

          # Detect affected packages
          PACKAGES_TO_RELEASE=""
          RELEASE_DATA=""

          # Check CLI changes
          CLI_CHANGED=$(echo "$RELEVANT_CHANGED_FILES" | grep "^apps/cli/" | grep -v "^apps/cli/docs/" | grep -v "^apps/cli/README.md" || echo "")
          if [ -n "$CLI_CHANGED" ]; then
            echo "CLI changes detected"
            PACKAGES_TO_RELEASE="$PACKAGES_TO_RELEASE @devex/cli"

            # Get current CLI version from latest tag
            CURRENT_CLI_VERSION=$(git tag | grep -E "^[0-9]+\.[0-9]+\.[0-9]+$" | sort -V | tail -1 || echo "0.0.0")
            NEW_CLI_VERSION=$(node -e "
              const [major, minor, patch] = '$CURRENT_CLI_VERSION'.split('.').map(Number);
              const bumpType = '$BUMP_TYPE';
              let newVersion;
              if (bumpType === 'major') newVersion = \`\${major + 1}.0.0\`;
              else if (bumpType === 'minor') newVersion = \`\${major}.\${minor + 1}.0\`;
              else newVersion = \`\${major}.\${minor}.\${patch + 1}\`;
              console.log(newVersion);
            ")
            RELEASE_DATA="$RELEASE_DATA @devex/cli:$NEW_CLI_VERSION"
          fi

          # Check Plugin SDK changes
          SDK_CHANGED=$(echo "$RELEVANT_CHANGED_FILES" | grep "^packages/plugin-sdk/" | grep -v "^packages/plugin-sdk/docs/" | grep -v "^packages/plugin-sdk/README.md" || echo "")
          if [ -n "$SDK_CHANGED" ]; then
            echo "Plugin SDK changes detected"
            PACKAGES_TO_RELEASE="$PACKAGES_TO_RELEASE @devex/plugin-sdk"

            # Get current SDK version from package.json
            CURRENT_SDK_VERSION=$(jq -r '.version // "0.0.0"' packages/plugin-sdk/package.json)
            NEW_SDK_VERSION=$(node -e "
              const [major, minor, patch] = '$CURRENT_SDK_VERSION'.split('.').map(Number);
              const bumpType = '$BUMP_TYPE';
              let newVersion;
              if (bumpType === 'major') newVersion = \`\${major + 1}.0.0\`;
              else if (bumpType === 'minor') newVersion = \`\${major}.\${minor + 1}.0\`;
              else newVersion = \`\${major}.\${minor}.\${patch + 1}\`;
              console.log(newVersion);
            ")
            RELEASE_DATA="$RELEASE_DATA @devex/plugin-sdk:$NEW_SDK_VERSION"
          fi

          # Check individual plugin changes
          for dir in packages/*/; do
            if [ "$dir" != "packages/plugin-sdk/" ]; then
              PACKAGE_NAME=$(basename "$dir")
              PLUGIN_CHANGED=$(echo "$RELEVANT_CHANGED_FILES" | grep "^$dir" | grep -v "^$dir/docs/" | grep -v "^$dir/README.md" || echo "")
              if [ -n "$PLUGIN_CHANGED" ]; then
                echo "Plugin $PACKAGE_NAME changes detected"
                PACKAGES_TO_RELEASE="$PACKAGES_TO_RELEASE @devex/$PACKAGE_NAME"

                # Get current plugin version
                CURRENT_PLUGIN_VERSION=$(jq -r '.version // "0.0.0"' "$dir/package.json")
                NEW_PLUGIN_VERSION=$(node -e "
                  const [major, minor, patch] = '$CURRENT_PLUGIN_VERSION'.split('.').map(Number);
                  const bumpType = '$BUMP_TYPE';
                  let newVersion;
                  if (bumpType === 'major') newVersion = \`\${major + 1}.0.0\`;
                  else if (bumpType === 'minor') newVersion = \`\${major}.\${minor + 1}.0\`;
                  else newVersion = \`\${major}.\${minor}.\${patch + 1}\`;
                  console.log(newVersion);
                ")
                RELEASE_DATA="$RELEASE_DATA @devex/$PACKAGE_NAME:$NEW_PLUGIN_VERSION"
              fi
            fi
          done

          # Clean up whitespace
          PACKAGES_TO_RELEASE=$(echo "$PACKAGES_TO_RELEASE" | xargs)
          RELEASE_DATA=$(echo "$RELEASE_DATA" | xargs)

          echo "Packages to release: $PACKAGES_TO_RELEASE"
          echo "Release data: $RELEASE_DATA"

          if [ -z "$PACKAGES_TO_RELEASE" ]; then
            echo "No packages need releasing"
            echo "has_release=false" >> $GITHUB_OUTPUT
          else
            echo "has_release=true" >> $GITHUB_OUTPUT
            echo "packages=$PACKAGES_TO_RELEASE" >> $GITHUB_OUTPUT
            echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
            echo "release_data=$RELEASE_DATA" >> $GITHUB_OUTPUT
          fi
  # Job 2: Build and release CLI
  release-cli:
    name: Release CLI
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has_release == 'true' && contains(needs.detect-changes.outputs.packages, '@devex/cli')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: false # Disable to avoid cache conflicts
      - name: Clean workspace
        run: |
          # Remove any existing dist files to prevent dirty git state
          rm -rf apps/cli/dist/
          git status
      - name: Extract CLI version
        id: version
        run: |
          RELEASE_DATA="${{ needs.detect-changes.outputs.release_data }}"
          CLI_VERSION=$(echo "$RELEASE_DATA" | grep -o "@devex/cli:[0-9.]*" | cut -d: -f2)
          echo "version=$CLI_VERSION" >> $GITHUB_OUTPUT
          echo "CLI version: $CLI_VERSION"
      - name: Install GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser-pro
          version: '~> v2'
          install-only: true
        env:
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}
      - name: Create tag and release
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Set up git user (from repo root)
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if tag already exists
          if git rev-parse --verify "refs/tags/$VERSION" >/dev/null 2>&1; then
            echo "Tag $VERSION already exists, skipping tag creation"
          else
            echo "Creating tag $VERSION"
            git tag -a "$VERSION" -m "Release @devex/cli $VERSION"
            git push origin "$VERSION" || echo "Failed to push tag, but continuing..."
          fi

          # Run GoReleaser in CLI directory
          cd apps/cli
          goreleaser release --clean -f .goreleaser.yml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}
      - name: Update package.json version
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          jq ".version = \"$VERSION\"" apps/cli/package.json > apps/cli/package.json.tmp
          mv apps/cli/package.json.tmp apps/cli/package.json

          # Commit version update with conflict handling
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add apps/cli/package.json
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: bump CLI version to $VERSION [skip ci]"
            # Pull latest changes and rebase to handle conflicts
            git pull --rebase origin main || echo "Rebase conflict, continuing..."
            git push origin main || echo "Push failed, another job may have pushed first"
          fi
  # Job 3: Build and release Plugin SDK
  release-plugin-sdk:
    name: Release Plugin SDK
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has_release == 'true' && contains(needs.detect-changes.outputs.packages, '@devex/plugin-sdk')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: false
      - name: Extract SDK version
        id: version
        run: |
          RELEASE_DATA="${{ needs.detect-changes.outputs.release_data }}"
          SDK_VERSION=$(echo "$RELEASE_DATA" | grep -o "@devex/plugin-sdk:[0-9.]*" | cut -d: -f2)
          echo "version=$SDK_VERSION" >> $GITHUB_OUTPUT
          echo "SDK version: $SDK_VERSION"
      - name: Install GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser-pro
          version: '~> v2'
          install-only: true
        env:
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}
      - name: Create tag and release
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          TAG="@devex/plugin-sdk@$VERSION"

          # Set up git user
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if tag already exists
          if git rev-parse --verify "refs/tags/$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping tag creation"
          else
            echo "Creating tag $TAG"
            git tag -a "$TAG" -m "Release @devex/plugin-sdk $VERSION"
            git push origin "$TAG"
          fi

          # Check if GoReleaser config exists and run in correct directory
          if [ -f "packages/plugin-sdk/.goreleaser.yml" ]; then
            cd packages/plugin-sdk
            goreleaser release --clean -f .goreleaser.yml
          else
            echo "No GoReleaser config found for plugin-sdk, skipping binary release"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}
      - name: Update package.json version
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          jq ".version = \"$VERSION\"" packages/plugin-sdk/package.json > packages/plugin-sdk/package.json.tmp
          mv packages/plugin-sdk/package.json.tmp packages/plugin-sdk/package.json

          # Commit version update with conflict handling
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add packages/plugin-sdk/package.json
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "chore: bump plugin-sdk version to $VERSION [skip ci]"
            # Pull latest changes and rebase to handle conflicts
            git pull --rebase origin main || echo "Rebase conflict, continuing..."
            git push origin main || echo "Push failed, another job may have pushed first"
          fi
  # Job 4: Release individual plugins
  release-plugins:
    name: Release Plugins
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has_release == 'true'
    strategy:
      matrix:
        package: ${{ fromJson('["@devex/package-manager-apt", "@devex/package-manager-dnf", "@devex/tool-git"]') }} # Add more as needed
      fail-fast: false # Don't stop other releases if one fails
    steps:
      - name: Check if package needs release
        id: check
        run: |
          PACKAGES="${{ needs.detect-changes.outputs.packages }}"
          if echo "$PACKAGES" | grep -q "${{ matrix.package }}"; then
            echo "needs_release=true" >> $GITHUB_OUTPUT
          else
            echo "needs_release=false" >> $GITHUB_OUTPUT
          fi
      - name: Checkout
        if: steps.check.outputs.needs_release == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Setup Go
        if: steps.check.outputs.needs_release == 'true'
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: false
      - name: Extract plugin version
        if: steps.check.outputs.needs_release == 'true'
        id: version
        run: |
          RELEASE_DATA="${{ needs.detect-changes.outputs.release_data }}"
          PLUGIN_VERSION=$(echo "$RELEASE_DATA" | grep -o "${{ matrix.package }}:[0-9.]*" | cut -d: -f2)
          echo "version=$PLUGIN_VERSION" >> $GITHUB_OUTPUT
          echo "Plugin version: $PLUGIN_VERSION"
      - name: Install GoReleaser
        if: steps.check.outputs.needs_release == 'true'
        uses: goreleaser/goreleaser-action@v6
        with:
          distribution: goreleaser-pro
          version: '~> v2'
          install-only: true
        env:
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}
      - name: Create tag and release
        if: steps.check.outputs.needs_release == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          PACKAGE="${{ matrix.package }}"
          TAG="$PACKAGE@$VERSION"
          PLUGIN_NAME=$(echo "$PACKAGE" | sed 's/@devex\///')
          # Create clean semver tag for GoReleaser (without scoped package prefix)
          CLEAN_TAG="v$VERSION"

          # Set up git user
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if scoped tag already exists
          if git rev-parse --verify "refs/tags/$TAG" >/dev/null 2>&1; then
            echo "Tag $TAG already exists, skipping tag creation"
          else
            echo "Creating tag $TAG"
            git tag -a "$TAG" -m "Release $PACKAGE $VERSION"
            git push origin "$TAG" || echo "Failed to push tag, but continuing..."
          fi

          # Create clean semver tag for GoReleaser if it doesn't exist
          if git rev-parse --verify "refs/tags/$CLEAN_TAG" >/dev/null 2>&1; then
            echo "Clean tag $CLEAN_TAG already exists"
          else
            echo "Creating clean tag $CLEAN_TAG for GoReleaser"
            git tag -a "$CLEAN_TAG" -m "Release $PACKAGE $VERSION (GoReleaser tag)"
            git push origin "$CLEAN_TAG" || echo "Failed to push clean tag, but continuing..."
          fi

          # Check if GoReleaser config exists and run from root with proper context
          if [ -f "packages/$PLUGIN_NAME/.goreleaser.yml" ]; then
            echo "Running GoReleaser for $PLUGIN_NAME with clean tag $CLEAN_TAG"
            # Run from root directory to maintain git context, use clean semver tag
            GORELEASER_CURRENT_TAG="$CLEAN_TAG" goreleaser release --clean -f "packages/$PLUGIN_NAME/.goreleaser.yml"
          else
            echo "No GoReleaser config found for $PLUGIN_NAME, skipping binary release"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GORELEASER_KEY: ${{ secrets.GORELEASER_KEY }}
      - name: Update package.json version
        if: steps.check.outputs.needs_release == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          PACKAGE="${{ matrix.package }}"
          PLUGIN_NAME=$(echo "$PACKAGE" | sed 's/@devex\///')

          if [ -f "packages/$PLUGIN_NAME/package.json" ]; then
            jq ".version = \"$VERSION\"" "packages/$PLUGIN_NAME/package.json" > "packages/$PLUGIN_NAME/package.json.tmp"
            mv "packages/$PLUGIN_NAME/package.json.tmp" "packages/$PLUGIN_NAME/package.json"

            # Commit version update with conflict handling
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add "packages/$PLUGIN_NAME/package.json"
            if git diff --staged --quiet; then
              echo "No changes to commit"
            else
              git commit -m "chore: bump $PLUGIN_NAME version to $VERSION [skip ci]"
              # Pull latest changes and rebase to handle conflicts
              git pull --rebase origin main || echo "Rebase conflict, continuing..."
              git push origin main || echo "Push failed, another job may have pushed first"
            fi
          fi
  # Job 5: Update plugin registry
  update-registry:
    name: Update Plugin Registry
    runs-on: ubuntu-latest
    needs: [detect-changes, release-cli, release-plugin-sdk, release-plugins]
    if: always() && needs.detect-changes.outputs.has_release == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
      - name: Update plugin registry
        run: |
          # Install registry script dependencies
          cd scripts
          npm install @octokit/rest
          cd ..

          # Wait a moment for releases to be available
          sleep 30

          # Generate complete registry from all plugin tags
          echo "Updating plugin registry..."
          node scripts/generate-registry.js all
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # Job 6: Notify on completion
  notify:
    name: Notify Release Completion
    runs-on: ubuntu-latest
    needs: [detect-changes, release-cli, release-plugin-sdk, release-plugins, update-registry]
    if: always() && needs.detect-changes.outputs.has_release == 'true'
    steps:
      - name: Notify success
        if: needs.update-registry.result == 'success'
        run: |
          echo "✅ Release completed successfully!"
          echo "Released packages: ${{ needs.detect-changes.outputs.packages }}"
          echo "Bump type: ${{ needs.detect-changes.outputs.bump_type }}"
      - name: Notify failure
        if: needs.update-registry.result == 'failure' || contains(needs.*.result, 'failure')
        run: |-
          echo "❌ Release failed!"
          echo "Check the job logs for details"
          exit 1
